package models

import play.api.db._
import play.api.Play.current

import anorm._
import anorm.SqlParser._
import scala.Long
import org.joda.time.DateTime
import com.googlecode.mapperdao._
import anorm.~
import models.Page
import utils.Setup

/**
 *
 * @author knm
 */


import com.googlecode.mapperdao.Query._


/**
 * Helper for pagination.
 */
case class Page[A](items: Seq[A], page: Int, offset: Long, total: Long) {
  lazy val prev = Option(page - 1).filter(_ >= 0)
  lazy val next = Option(page + 1).filter(_ => (offset + items.size) < total)
  lazy val totalPages = Option(total / items.size.toLong).filter(_>= 0)
}



case class Media(publishingDate: DateTime, author:Option[String], title: String,
subtitle : Option[String], identifier: Option[String], description : Option[String],
var consumed : Boolean = false, showId: Option[String])


object MediaEntity extends Entity[LongId, Media]{
  val id = key("id") autogenerated (_.id)
  val publishingDate = key("publishingDate") to (_.publishingDate)
  val author = column("author") option (_.author)
  val title = column("title") to  (_.title)
  val subtitle = column("subtitle") option  (_.subtitle)
  val identifier = column("identifier") option (_.identifier)
  val description = column("description") option (_.description)
  val consumed = column("consumed") to (_.consumed)
  val showId = column("showId") option (_.showId)

  def constructor(implicit m: ValuesMap) =
  new Media(publishingDate, author, title, subtitle, identifier, description, consumed, showId) with LongId with Persisted  {
    val id: Long = MediaEntity.id
  }
}






object Media {

val dataSource = play.db.DB.getDataSource("default")
  val(jdbc, mapperDao, queryDao, transcationManager) = Setup.mysql(dataSource, List(MediaEntity, TVShowEntity))
  val me = MediaEntity
  val ts = TVShowEntity

   def findById(id:Long): Option[Media] = {
     queryDao.querySingleResult(select from me where me.id === id)
   }


  def shows(page: Int = 0, pageSize: Int = 10, orderBy: Int = 1, filter: String = "%"): Page[TVShow] = {
    val offset = pageSize * page

    val shows = queryDao.query(QueryConfig(offset = Some(offset), limit = Some(pageSize)), select from ts)
    val totalRows = queryDao.count(select from ts)
    Page(shows, page, offset, totalRows)


    //        """
    //      select title, count(*) as count
    //      from media
    //      group by title
    //      order by {orderBy} nulls last
    //      limit {pageSize} offset {offset}
    //      """).on(
    //        'pageSize -> pageSize,
    //        'offset -> offset,
    //        'orderBy -> orderBy
    //      ).as(TShow.simple *)

    //      val totalRows = SQL(
    //        """
    //      select distinct(title) from media
    //      """


  }

  def all(page: Int = 0, pageSize: Int = 10, orderBy: Int = 1, filter: String = "%"): Page[(Media)] = {
    val offset = pageSize * page

    val query: OrderBy[Builder[LongId, Media]] with Builder[LongId, Media] = select from me orderBy(me.title, asc)
    val medias = queryDao.query(QueryConfig(offset = Some(offset), limit = Some(pageSize)), query)
    val totalRows = queryDao.count(query)
//        """
//      select * from media
//      order by {orderBy} nulls last
//      limit {pageSize} offset {offset}
//      """).on(
//        'pageSize -> pageSize,
//        'offset -> offset,
//        'orderBy -> orderBy

//      val totalRows = SQL(
//        """
//          select count(*) from media
//        """

      Page(medias, page, offset, totalRows)
  }

  /**
   * Get Shows for a title
   *
   * @param title
   * @param page
   * @param pageSize
   * @param orderBy
   * @return
   */
  def show(title: String, page: Int = 0, pageSize: Int = 10, orderBy: Int = 1): Page[(Media)] = {
    val offset = pageSize * page
    val query = select from me where me.title === title orderBy(me.publishingDate)
    val medias = queryDao.query(QueryConfig(offset = Some(offset), limit = Some(pageSize)), query)
    val totalRows = queryDao.count(query)

//        """
//      select * from media
//      where title = {title}
//      order by publishingDate nulls last
//      limit {pageSize} offset {offset}
//      """).on(
//        'title -> title,
//        'pageSize -> pageSize,
//        'offset -> offset,
//        'orderBy -> orderBy
//      val totalRows = SQL(
//              """
//            select count(*) from media
//            where title = {title}
//            """)
//        .on('title -> title)

      Page(medias, page, offset, totalRows)
  }

  def recent(limit : Int = 4) : Seq[Media] =  {
    val medias = queryDao.query(QueryConfig(limit = Some(limit)), select from me where me.publishingDate < DateTime.now  orderBy (me.publishingDate, asc))
    medias
  }

  def consume(id:Long, consume:Boolean) = {
//    DB.withConnection{ implicit connection  =>
//      SQL(
//        """
//        update media
//        set consumed  = {consume}
//        where id = {id}
//        """
//      ).on(
//        'consume -> consume,
//        'id -> id
//      ).executeUpdate()
//
//      if(consume)
//      {
//        DB.withConnection{ implicit connection =>
//          SQL("""
//          update media
//          set consumed = 1
//          where title = (select title from media where id = {id})
//          and publishingDate < (select publishingDate from media where id = {id})
//        """).on(
//            'id -> id
//          ).executeUpdate()
//        }
//      }
//    }
  }

  def consumeAll(title:String) = {
    DB.withConnection{ implicit connection  =>
      SQL(
      """
      update media
      set consumed  = 1
      where title = {title}
      """
      ).on(
      'title -> title
      ).executeUpdate()
    }
  }

  def upcoming(limit : Int = 4) : Seq[Media] =  {
    queryDao.query(QueryConfig(limit = Some(limit)), select from me where me.publishingDate >= DateTime.now orderBy (me.publishingDate, asc))
//    DB.withConnection{ implicit connection =>
//    val medias = SQL(
//      """
//      select * from media
//      where publishingDate >= {today}
//      order by publishingDate asc nulls last
//      limit {limit}
//      """).on(
//      'today -> new java.util.Date(),
//      'limit -> limit
//    ).as(simple *)
//    medias
//    }
  }

  def delete(title: String) = {
    val medias = queryDao.query(select from me where me.title === title)
    medias.map{ mapperDao.delete(me, _) }
  }
}

case class TVShow(title : String, count : Long)

object TVShowEntity extends SimpleEntity[TVShow]{
  val title = key("title") to (_.title)
  val count = column("count") to (_.count)

  def constructor(implicit m: ValuesMap) =
    new TVShow(title, count) with Persisted  {
    }
}
